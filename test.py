import matplotlib.pyplot as plt
import pywt
import numpy as np


def wavelet_features(signal, wavelet='db4', level=5):
    # Выполняем вейвлет-декомпозицию
    coeffs = pywt.wavedec(signal, wavelet, level=level)
    # for i in coeffs:
        # plt.plot(i)
        # plt.show()

    features = []
    for i, coeff in enumerate(coeffs):
        # Вычисляем энергию коэффициентов
        energy = np.sum(coeff ** 2)
        features.append(energy)

        # Вычисляем статистики коэффициентов
        features.extend([np.mean(coeff), np.std(coeff), np.max(coeff), np.min(coeff)])

    return features


# Применение к вашему сигналу
signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]

wavelet_features = wavelet_features(signal)

print(wavelet_features)

plt.plot(wavelet_features[1:])
plt.show()

import pywt
import numpy as np
import matplotlib.pyplot as plt

# Создаем тестовый сигнал с шумом
# t = np.linspace(0, 1, 1000, endpoint=False)
# signal = np.sin(2 * np.pi * 10 * t) + np.sin(2 * np.pi * 20 * t)
# noisy_signal = signal + 0.5 * np.random.randn(len(t))

noisy_signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]
# Применяем вейвлет-преобразование
wavelet = 'db4'
level = 5
coeffs = pywt.wavedec(noisy_signal, wavelet, level=level)

# Оцениваем уровень шума
sigma = np.median(np.abs(coeffs[-1])) / 0.6745

# Вычисляем порог
N = len(noisy_signal)
threshold = sigma * np.sqrt(2 * np.log(N))

# Применяем мягкую пороговую обработку
denoised_coeffs = [pywt.threshold(c, threshold, mode='soft') for c in coeffs]

# Выполняем обратное вейвлет-преобразование
denoised_signal = pywt.waverec(denoised_coeffs, wavelet)

# Визуализируем результаты
plt.figure(figsize=(12, 8))
plt.subplot(3, 1, 1)
plt.plot(noisy_signal)
plt.title('Исходный сигнал')
plt.subplot(3, 1, 2)
plt.plot(noisy_signal)
plt.title('Сигнал с шумом')
plt.subplot(3, 1, 3)
plt.plot(denoised_signal)
plt.title('Очищенный сигнал')
plt.tight_layout()
plt.show()


import numpy as np
import matplotlib.pyplot as plt
import pywt

# Создаем тестовый сигнал
t = np.linspace(0, 1, 512, endpoint=False)
signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]

# Задаем параметры CWT
scales = np.arange(1, 128)
wavelet = 'cmor1.5-1.0'

# Выполняем CWT
coefficients, frequencies = pywt.cwt(signal, scales, wavelet)

# Визуализируем результаты
plt.figure(figsize=(12, 8))
plt.subplot(211)
plt.plot(t, signal)
plt.title('Исходный сигнал')
plt.subplot(212)
plt.imshow(np.abs(coefficients), extent=[0, 1, 1, 128], cmap='jet', aspect='auto', 
           vmax=abs(coefficients).max(), vmin=-abs(coefficients).max())
plt.colorbar(label='Magnitude')
plt.ylabel('Scale')
plt.xlabel('Time')
plt.title('Непрерывное вейвлет-преобразование')
plt.tight_layout()
plt.show()


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import pywt

# Создаем тестовый сигнал
# t = np.linspace(0, 1, 1000, endpoint=False)
# signal = np.sin(2 * np.pi * 10 * t) + np.sin(2 * np.pi * 20 * t)
#
t = np.linspace(0, 1, 512, endpoint=False)
signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]
# Задаем параметры CWT
scales = np.arange(1, 128)
wavelet = 'morl'

# Выполняем CWT
coefficients, frequencies = pywt.cwt(signal, scales, wavelet)

# Создаем сетку для 3D графика
T, S = np.meshgrid(t, scales)

# Создаем 3D график
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# Строим поверхность
surf = ax.plot_surface(T, S, np.abs(coefficients), cmap='jet',
                       linewidth=0, antialiased=False)

# Настраиваем оси
ax.set_xlabel('Время')
ax.set_ylabel('Масштаб')
ax.set_zlabel('Амплитуда')
ax.set_title('3D представление непрерывного вейвлет-преобразования')

# Добавляем цветовую шкалу
fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5)

# Настраиваем угол обзора
ax.view_init(elev=30, azim=45)

plt.tight_layout()
plt.show()