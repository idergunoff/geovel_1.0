from pyexpat import features

from func import *


# Расчет вейвлет-параметров



def wavelet_features(signal, wavelet='db4', level=5):
    coeffs = pywt.wavedec(signal, wavelet, level=level)
    features = []

    for i, coeff in enumerate(coeffs):
        energy = np.sum(coeff ** 2)
        mean = np.mean(coeff)
        std = np.std(coeff)
        skewness = skew(coeff)
        kurt = kurtosis(coeff)


        features.extend([energy, mean, std, skewness, kurt, np.max(coeff), np.min(coeff)])

    return features


def energy_ratio_features(signal, wavelet='db4', level=5):
    coeffs = pywt.wavedec(signal, wavelet, level=level)
    energies = [np.sum(coeff**2) for coeff in coeffs]
    ratios = [energies[i] / energies[i+1] for i in range(len(energies)-1)]
    return ratios


def approximation_features(signal, wavelet='db4', level=5):
    coeffs = pywt.wavedec(signal, wavelet, level=level)
    print(len(coeffs[0]))
    return coeffs[0]  # коэффициенты аппроксимации последнего уровня


def wavelet_entropy_features(signal, wavelet='db4', level=5):
    coeffs = pywt.wavedec(signal, wavelet, level=level)
    entropies = []

    for coeff in coeffs:
        prob = np.abs(coeff) / np.sum(np.abs(coeff))
        entropies.append(entropy(prob))

    return entropies


def high_low_frequency_ratio_all(signal, wavelet='db4', level=5):
    coeffs = pywt.wavedec(signal, wavelet, level=level)

    low_freq_energy = np.sum(coeffs[0] ** 2)
    high_freq_energy = sum(np.sum(coeff ** 2) for coeff in coeffs[1:])
    ratios = [np.sum(coeff ** 2) / low_freq_energy for coeff in coeffs[1:]]
    ratios.append(high_freq_energy / low_freq_energy)

    return ratios


def extract_wavelet_features(signal, wavelet='db4', level=5):
    features = []

    # Базовые признаки
    features.extend(wavelet_features(signal, wavelet, level))

    # Отношение энергий
    features.extend(energy_ratio_features(signal, wavelet, level))

    # Коэффициенты аппроксимации
    features.extend(approximation_features(signal, wavelet, level))

    # Энтропия
    features.extend(wavelet_entropy_features(signal, wavelet, level))

    # Отношение высоких/низких частот
    features.extend(high_low_frequency_ratio_all(signal, wavelet, level))

    return features


# Конец расчета параметров вейвлет


signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]
signal2 = np.array([121, 165, 255, 217, 3, 3, 3, 255, 133, 3, 3, 3, 235, 255, 255, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 195, 137, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 205, 207, 139, 55, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 27, 47, 59, 61, 81, 105, 135, 145, 151, 149, 185, 199, 207, 219, 239, 247, 241, 237, 243, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 251, 251, 255, 255, 255, 255, 255, 255, 251, 249, 237, 233, 237, 239, 249, 251, 249, 233, 233, 227, 239, 247, 249, 251, 247, 243, 241, 231, 225, 221, 217, 215, 205, 205, 201, 201, 193, 195, 193, 205, 189, 193, 199, 199, 203, 203, 201, 177, 173, 173, 179, 179, 181, 181, 179, 175, 181, 189, 187, 185, 187, 175, 167, 161, 159, 159, 153, 149, 147, 155, 153, 149, 161, 165, 169, 163, 159, 155, 153, 159, 161, 155, 147, 141, 147, 151, 159, 159, 153, 143, 135, 135, 143, 145, 147, 149, 141, 141, 137, 135, 135, 141, 139, 135, 137, 137, 137, 143, 145, 145, 149, 143, 131, 125, 127, 137, 137, 131, 127, 135, 127, 127, 133, 145, 143, 143, 135, 137, 135, 141, 143, 145, 143, 139, 135, 127, 131, 137, 143, 131, 125, 133, 129, 135, 135, 141, 139, 129, 131, 129, 121, 125, 131, 135, 125, 129, 129, 131, 137, 145, 145, 135, 139, 137, 127, 125, 129, 133, 133, 129, 135, 129, 127, 137, 145, 141, 141, 135, 133, 127, 131, 135, 143, 135, 127, 131, 121, 121, 135, 137, 129, 123, 133, 133, 133, 135, 143, 139, 135, 131, 127, 127, 131, 137, 139, 129, 129, 129, 129, 135, 141, 143, 139, 129, 133, 127, 129, 129, 137, 133, 125, 127, 127, 119, 129, 133, 135, 127, 127, 131, 127, 131, 141, 145, 145, 139, 133, 125, 123, 127, 133, 127, 123, 129, 129, 127, 131, 137, 141, 133, 131, 125, 125, 123, 135, 145, 131, 129, 133, 125, 129, 137, 147, 137, 127, 131, 133, 127, 131, 137, 137, 129, 127, 131, 131, 137, 139, 145, 131, 125, 129, 123, 127, 133, 135, 129, 129, 129, 127, 123, 129, 139, 135, 137, 131, 131, 125, 133, 141, 143, 133, 131, 129, 125, 129, 133, 143, 135, 135, 131, 129, 127, 135, 135, 133, 129, 129, 127, 133, 141, 143, 141, 143, 133, 133, 127, 133, 137, 141, 133, 129, 135, 129, 131, 135, 141, 133, 131, 131, 129, 131, 133, 137, 137, 135, 133, 131, 129, 139, 141, 143, 133, 133, 131, 129, 133][140:199])
signal = np.array([121, 165, 255, 217, 3, 3, 3, 255, 133, 3, 3, 3, 235, 255, 255, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 195, 137, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 205, 207, 139, 55, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 27, 47, 59, 61, 81, 105, 135, 145, 151, 149, 185, 199, 207, 219, 239, 247, 241, 237, 243, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 251, 251, 255, 255, 255, 255, 255, 255, 251, 249, 237, 233, 237, 239, 249, 251, 249, 233, 233, 227, 239, 247, 249, 251, 247, 243, 241, 231, 225, 221, 217, 215, 205, 205, 201, 201, 193, 195, 193, 205, 189, 193, 199, 199, 203, 203, 201, 177, 173, 173, 179, 179, 181, 181, 179, 175, 181, 189, 187, 185, 187, 175, 167, 161, 159, 159, 153, 149, 147, 155, 153, 149, 161, 165, 169, 163, 159, 155, 153, 159, 161, 155, 147, 141, 147, 151, 159, 159, 153, 143, 135, 135, 143, 145, 147, 149, 141, 141, 137, 135, 135, 141, 139, 135, 137, 137, 137, 143, 145, 145, 149, 143, 131, 125, 127, 137, 137, 131, 127, 135, 127, 127, 133, 145, 143, 143, 135, 137, 135, 141, 143, 145, 143, 139, 135, 127, 131, 137, 143, 131, 125, 133, 129, 135, 135, 141, 139, 129, 131, 129, 121, 125, 131, 135, 125, 129, 129, 131, 137, 145, 145, 135, 139, 137, 127, 125, 129, 133, 133, 129, 135, 129, 127, 137, 145, 141, 141, 135, 133, 127, 131, 135, 143, 135, 127, 131, 121, 121, 135, 137, 129, 123, 133, 133, 133, 135, 143, 139, 135, 131, 127, 127, 131, 137, 139, 129, 129, 129, 129, 135, 141, 143, 139, 129, 133, 127, 129, 129, 137, 133, 125, 127, 127, 119, 129, 133, 135, 127, 127, 131, 127, 131, 141, 145, 145, 139, 133, 125, 123, 127, 133, 127, 123, 129, 129, 127, 131, 137, 141, 133, 131, 125, 125, 123, 135, 145, 131, 129, 133, 125, 129, 137, 147, 137, 127, 131, 133, 127, 131, 137, 137, 129, 127, 131, 131, 137, 139, 145, 131, 125, 129, 123, 127, 133, 135, 129, 129, 129, 127, 123, 129, 139, 135, 137, 131, 131, 125, 133, 141, 143, 133, 131, 129, 125, 129, 133, 143, 135, 135, 131, 129, 127, 135, 135, 133, 129, 129, 127, 133, 141, 143, 141, 143, 133, 133, 127, 133, 137, 141, 133, 129, 135, 129, 131, 135, 141, 133, 131, 131, 129, 131, 133, 137, 137, 135, 133, 131, 129, 139, 141, 143, 133, 133, 131, 129, 133][250:450])

features_signal = extract_wavelet_features(signal, wavelet='db4', level=5)
print(features_signal)

plt.plot(features_signal[1:])
plt.show()


def wavelet_features(signal, wavelet='db4', level=5):
    # Выполняем вейвлет-декомпозицию
    coeffs = pywt.wavedec(signal, wavelet, level=level)
    for i in coeffs:
        plt.plot(i)
        plt.show()

    features = []
    for i, coeff in enumerate(coeffs):
        # Вычисляем энергию коэффициентов
        energy = np.sum(coeff ** 2)
        features.append(energy)

        # Вычисляем статистики коэффициентов
        features.extend([np.mean(coeff), np.std(coeff), np.max(coeff), np.min(coeff)])

    return features


# Применение к вашему сигналу
signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ][250:450]

wavelet_features = wavelet_features(signal)

plt.plot(wavelet_features[1:])
plt.show()

import pywt
import numpy as np
import matplotlib.pyplot as plt

# Создаем тестовый сигнал с шумом
# t = np.linspace(0, 1, 1000, endpoint=False)
# signal = np.sin(2 * np.pi * 10 * t) + np.sin(2 * np.pi * 20 * t)
# noisy_signal = signal + 0.5 * np.random.randn(len(t))

# Применяем вейвлет-преобразование
noisy_signal = signal2
wavelet = 'db4'
level = 5
coeffs = pywt.wavedec(noisy_signal, wavelet, level=level)

# Оцениваем уровень шума
sigma = np.median(np.abs(coeffs[-1])) / 0.6745

# Вычисляем порог
N = len(noisy_signal)
threshold = sigma * np.sqrt(2 * np.log(N))

# Применяем мягкую пороговую обработку
denoised_coeffs = [pywt.threshold(c, threshold, mode='soft') for c in coeffs]

# Выполняем обратное вейвлет-преобразование
denoised_signal = pywt.waverec(denoised_coeffs, wavelet)

# Визуализируем результаты
plt.figure(figsize=(12, 8))
plt.subplot(2, 1, 1)
plt.plot(noisy_signal)
plt.title('Исходный сигнал')

plt.subplot(2, 1, 2)
plt.plot(denoised_signal)
plt.title('Очищенный сигнал')
plt.tight_layout()
plt.show()


import numpy as np
import matplotlib.pyplot as plt
import pywt

# Создаем тестовый сигнал
t = np.linspace(0, 1, 512, endpoint=False)
signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]

# Задаем параметры CWT
scales = np.arange(1, 128)
wavelet = 'cmor1.5-1.0'

# Выполняем CWT
coefficients, frequencies = pywt.cwt(signal, scales, wavelet)

# Визуализируем результаты
plt.figure(figsize=(12, 8))
plt.subplot(211)
plt.plot(t, signal)
plt.title('Исходный сигнал')
plt.subplot(212)
plt.imshow(np.abs(coefficients), extent=[0, 1, 1, 128], cmap='jet', aspect='auto', 
           vmax=abs(coefficients).max(), vmin=-abs(coefficients).max())
plt.colorbar(label='Magnitude')
plt.ylabel('Scale')
plt.xlabel('Time')
plt.title('Непрерывное вейвлет-преобразование')
plt.tight_layout()
plt.show()


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import pywt

# Создаем тестовый сигнал
# t = np.linspace(0, 1, 1000, endpoint=False)
# signal = np.sin(2 * np.pi * 10 * t) + np.sin(2 * np.pi * 20 * t)
#
t = np.linspace(0, 1, 512, endpoint=False)
signal = [169, 219, 255, 101, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 17, 195, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 235, 209, 185, 183, 187, 187, 183, 187, 197, 197, 199, 207, 203, 191, 179, 169, 155, 143, 139, 129, 131, 131, 137, 139, 139, 137, 137, 137, 137, 127, 115, 111, 111, 115, 117, 125, 123, 129, 127, 123, 113, 103, 107, 103, 113, 113, 121, 123, 131, 135, 129, 117, 109, 105, 95, 97, 99, 103, 107, 111, 113, 121, 131, 131, 131, 129, 121, 117, 113, 113, 113, 113, 117, 111, 101, 93, 97, 103, 111, 117, 121, 129, 123, 119, 117, 115, 119, 127, 127, 125, 125, 121, 117, 117, 121, 123, 119, 117, 115, 117, 119, 125, 129, 129, 123, 119, 115, 119, 121, 123, 127, 129, 127, 131, 123, 121, 119, 119, 121, 123, 129, 133, 133, 129, 131, 131, 131, 133, 129, 125, 127, 119, 117, 123, 123, 131, 129, 121, 125, 127, 125, 129, 135, 137, 133, 135, 131, 133, 133, 133, 131, 131, 131, 129, 125, 127, 129, 125, 129, 123, 127, 131, 135, 131, 133, 135, 135, 137, 133, 137, 131, 131, 135, 135, 135, 137, 133, 133, 127, 125, 129, 131, 129, 131, 131, 127, 133, 135, 135, 137, 139, 137, 135, 133, 127, 133, 135, 135, 135, 133, 133, 131, 133, 131, 133, 135, 133, 133, 135, 133, 131, 129, 127, 133, 137, 137, 129, 129, 133, 131, 133, 133, 135, 137, 137, 133, 133, 137, 137, 133, 135, 129, 129, 125, 127, 131, 131, 137, 135, 135, 133, 129, 131, 131, 135, 135, 135, 133, 127, 129, 131, 131, 137, 133, 131, 129, 129, 133, 133, 133, 131, 135, 137, 133, 129, 131, 131, 133, 137, 137, 135, 129, 127, 127, 129, 133, 137, 135, 135, 133, 127, 129, 129, 129, 133, 133, 129, 125, 131, 133, 133, 133, 135, 131, 131, 131, 133, 135, 135, 139, 137, 133, 131, 131, 131, 131, 131, 131, 133, 133, 133, 131, 129, 131, 135, 131, 133, 129, 129, 131, 131, 133, 133, 131, 135, 129, 125, 131, 135, 137, 137, 139, 129, 129, 125, 125, 131, 133, 135, 135, 135, 129, 127, 125, 127, 135, 135, 139, 137, 131, 131, 131, 133, 131, 133, 133, 131, 127, 129, 131, 135, 133, 131, 131, 131, 129, 127, 131, 131, 133, 135, 135, 133, 131, 127, 125, 133, 133, 135, 127, 123, 129, 129, 133, 133, 133, 131, 129, 125, 131, 131, 133, 133, 135, 131, 129, 127, 129, 131, 133, 133, 137, 133, 131, 131, 127, 127, 129, 131, 131, 129, 129, 131, 129, 131, 131, 133, 137, 129 ]
# Задаем параметры CWT
scales = np.arange(1, 128)
wavelet = 'morl'

# Выполняем CWT
coefficients, frequencies = pywt.cwt(signal, scales, wavelet)

# Создаем сетку для 3D графика
T, S = np.meshgrid(t, scales)

# Создаем 3D график
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# Строим поверхность
surf = ax.plot_surface(T, S, np.abs(coefficients), cmap='jet',
                       linewidth=0, antialiased=False)

# Настраиваем оси
ax.set_xlabel('Время')
ax.set_ylabel('Масштаб')
ax.set_zlabel('Амплитуда')
ax.set_title('3D представление непрерывного вейвлет-преобразования')

# Добавляем цветовую шкалу
fig.colorbar(surf, ax=ax, shrink=0.5, aspect=5)

# Настраиваем угол обзора
ax.view_init(elev=30, azim=45)

plt.tight_layout()
plt.show()